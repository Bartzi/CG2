#version 140

out vec4 gl_FragColor;

uniform sampler2D source;
uniform vec2 invViewportSize;

// "random" sample and noise arrays generated by our python script
// kernel_generator.py (you can find it in the src folder)
vec3[16] samples = vec3[16](
	vec3(0.467405279786649, 0.7709692351897537, 0.43259535690815094),
	vec3(0.4860107296594518, 0.5757875739620788, 0.6574665317160647),
	vec3(0.1671221278636797, 0.6487159859683292, 0.7424538800002693),
	vec3(-0.8750320549701412, 0.20059380814384416, 0.44054628236892705),
	vec3(-0.6748374188517083, -0.30020418831719145, 0.6741453132926019),
	vec3(0.5677791188245099, 0.69577481227662, 0.4217079731236424),
	vec3(-0.26899165941694655, -0.9616438577310309, 0.053708268006877665),
	vec3(0.8798610735581641, -0.7298522086431353, 0.46959306721081624),
	vec3(-0.27388079639347404, -0.9598575113294905, 0.6052162680590963),
	vec3(-0.07576107970312814, 0.4484441223472641, 0.8905942555026998),
	vec3(0.4258229243934062, -0.56378366286407626, 0.7076883625923298),
	vec3(-0.3214491254136236, -0.12311991639553183, 0.9388886760194595),
	vec3(-0.23466592071241008, 0.3573677622830396, 0.9040023164444932),
	vec3(0.6446697326402659, 0.7149592566127301, 0.27061817603646017),
	vec3(0.8213893197887778, 0.20216063590955232, 0.5333391628462836),
	vec3(-0.31883940209354433, 0.7916663743149575, 0.6101211077611854));

vec3[16] noise = vec3[16](
	vec3(0.238593415166, 0.850826686175, 0),
	vec3(-0.484680513884, 0.692068488877, 0),
	vec3(0.799891857218, 0.584421084754, 0),
	vec3(-0.835141820182, 0.547220601021, 0),
	vec3(0.591034769874, -0.0428475244496, 0),
	vec3(-0.544297216588, 0.818276534478, 0),
	vec3(0.688544190419, -0.355482789811, 0),
	vec3(0.520350825586, 0.481841058432, 0),
	vec3(0.845254693003, -0.471876091638, 0),
	vec3(0.0109964623951, 0.271270687772, 0),
	vec3(0.275225440039, -0.711591710156, 0),
	vec3(-0.393027017083, -0.590736178759, 0),
	vec3(-0.218054821667, 0.116752890739, 0),
	vec3(-0.650862709657, 0.758647243224, 0),
	vec3(0.766738704455, -0.184769224671, 0),
	vec3(-0.835643122436, 0.526472298703, 0));

in vec2 v_uv;

void main(void)
{
	// Task 3a SSAO
	
	//-------------------------------------------------------------------------------------
	// inputs: 
	//	inverse viewport size to scale samples according to window size
	//	framebuffer from last rendering pass
	//	precalculated "random" kernels
	// assumptions:
	//	none
	// artifacts:
	//	rectangular repeatedly occuring pattern because of the noise kernel
	//	after blurring we have halos 
	// method:
	//	we use the method introduced in the exercise
	//  and as found on http://john-chapman-graphics.blogspot.de/2013/01/ssao-tutorial.html
	//-------------------------------------------------------------------------------------

	vec4 normalAndZData = texture(source, v_uv); 
	// calc index for noise array
	int xindex = int(mod(v_uv.x  * 10000.0, 4.0));
	int yindex = int(mod(v_uv.y * 10000.0, 4.0));
	vec3 noiseValue = noise[yindex * 4 + xindex];
	// construct orthonormal base with noiseVector and normal in order to 
	// align samples concerning the surface
	vec3 tangent = normalize(cross(normalAndZData.xyz, noiseValue));
	vec3 bitangent = cross(normalAndZData.xyz, tangent);
	mat3 orthonormalBase = mat3(tangent, bitangent, normalAndZData.xyz);


	float occlusion = 0.0;
	// do the sampling
	for(int i = 0; i < 16; ++i)
	{
		// get the sampleposition from sample array and rotate it 
		vec3 samplePosition = orthonormalBase * samples[i];
		// scale samplePosition
		samplePosition.xy *= invViewportSize.xy;
		// use sampleposition as offset to current position
		samplePosition.xy += v_uv;
		
		// get the depth at sampleposition
		float sampleDepth = texture(source, samplePosition.xy).a;
		
		// if samplepoint is inside geometry this point contributes to occlusion factor
		occlusion += (sampleDepth <= normalAndZData.a ? 1.0 : 0.0); 
	}

	// calculate amount of brightness
	occlusion = 1.0 - (occlusion / 16.0);

	// calculate diffuse lighting
	vec3 lightPos = vec3(5.0, 1.5, -1.2); // manually defined
	vec3 fragmentPosition = vec3(v_uv * 2.0 - 1.0, normalAndZData.a);
	vec3 invLightDir = normalize(lightPos - fragmentPosition);
	float intensity = dot(invLightDir, normalAndZData.xyz);
	
	// apply occlusionfactor to fragment
	//vec3 occludedColor = occlusion * vec3(normalAndZData.a);
    //gl_FragColor = vec4(occludedColor, intensity);
	gl_FragColor = vec4(vec3(occlusion), intensity);
}